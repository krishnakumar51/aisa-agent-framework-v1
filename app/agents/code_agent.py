"""
Code generation agent - Agent 2
Detects platform and generates automation scripts with artifact persistence
"""
import asyncio
import json
import os
from typing import Dict, Any, Optional
from app.models.schemas import WorkflowState, PlatformType
from app.utils.model_client import model_client

class CodeAgent:
    """Agent responsible for code generation and platform detection"""
    
    def __init__(self):
        self.name = "code_agent"
        self.description = "Generates automation scripts for web/mobile platforms"
    
    async def process(self, state: WorkflowState) -> WorkflowState:
        try:
            print(f"[{self.name}] Starting code generation...")
            state.current_agent = self.name

            # NEW: honor platform override from request parameters
            override = (state.parameters or {}).get("platform")
            if isinstance(override, str):
                ov = override.lower().strip()
                if ov == "web":
                    state.platform = PlatformType.WEB
                elif ov == "mobile":
                    state.platform = PlatformType.MOBILE

            # If still unknown, detect from blueprint
            if not state.platform or state.platform == PlatformType.UNKNOWN:
                detected = await self._detect_platform(state.json_blueprint or {})
                state.platform = detected

            # Generate script for chosen platform
            script = await self._generate_script(state.json_blueprint, state.platform)
            state.generated_script = script
            state.script_language = "python"

            # Persist Agent 2 artifact (unchanged)
            if state.run_dir:
                script_path = await self._save_agent2_script(state, script)
                state.artifacts["agent2_script_path"] = script_path
                print(f"[{self.name}] Script saved to: {script_path}")

            print(f"[{self.name}] Code generation completed for platform: {state.platform}")
            return state

        except Exception as e:
            print(f"[{self.name}] Error: {str(e)}")
            state.generated_script = f"# Error generating script: {str(e)}"
            state.platform = PlatformType.UNKNOWN
            return state

    
    async def _save_agent2_script(self, state: WorkflowState, script: str) -> str:
        """Save Agent 2 generated script to file"""
        try:
            os.makedirs(state.run_dir, exist_ok=True)
            script_path = os.path.join(state.run_dir, "agent-code-generator.py")
            
            # Create a proper Python script
            if script.strip().startswith("def ") or "import " in script or "from " in script:
                # Already a proper Python script
                content = script
            else:
                # Convert command-based script to Python
                content = self._convert_to_python_script(script, state.platform)
            
            # Add metadata header
            header = f'''"""
Generated by Agent 2 - Code Generator
Task ID: {state.task_id}
Platform: {state.platform}
Generated at: {state.updated_at}
"""

'''
            full_content = header + content
            
            # Write to file
            def _write_file(path: str, content: str):
                with open(path, "w", encoding="utf-8") as f:
                    f.write(content)
            
            await asyncio.to_thread(_write_file, script_path, full_content)
            return script_path
            
        except Exception as e:
            print(f"[{self.name}] Error saving script: {str(e)}")
            return ""
    
    def _convert_to_python_script(self, script: str, platform: PlatformType) -> str:
        """Convert command-based script to proper Python script"""
        if platform == PlatformType.MOBILE:
            return self._convert_to_appium_script(script)
        else:
            return self._convert_to_playwright_script(script)
    
    def _convert_to_appium_script(self, script: str) -> str:
        """Convert commands to Appium Python script"""
        lines = script.strip().split('\n')
        python_lines = [
            "import time",
            "from appium import webdriver",
            "from appium.options.android import UiAutomator2Options",
            "from appium.webdriver.common.appiumby import AppiumBy",
            "",
            "def execute_automation():",
            "    \"\"\"Generated Appium automation script\"\"\"",
            "    try:"
        ]
        
        for line in lines:
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            python_lines.append(f"        # Command: {line}")
            python_lines.append("        time.sleep(1)  # Wait between actions")
        
        python_lines.extend([
            "        return {'success': True, 'message': 'Automation completed'}",
            "    except Exception as e:",
            "        return {'success': False, 'error': str(e)}",
            "",
            "if __name__ == '__main__':",
            "    result = execute_automation()",
            "    print(result)"
        ])
        
        return "\n".join(python_lines)
    
    def _convert_to_playwright_script(self, script: str) -> str:
        """Convert commands to Playwright Python script"""
        lines = script.strip().split('\n')
        python_lines = [
            "import asyncio",
            "from playwright.async_api import async_playwright",
            "",
            "async def execute_automation():",
            "    \"\"\"Generated Playwright automation script\"\"\"",
            "    playwright = None",
            "    browser = None",
            "    try:",
            "        playwright = await async_playwright().start()",
            "        browser = await playwright.chromium.launch(headless=False)",
            "        page = await browser.new_page()",
            ""
        ]
        
        for line in lines:
            line = line.strip()
            if not line or line.startswith('#'):
                continue
                
            if line.startswith('navigate'):
                url = line.split('navigate')[1].strip().strip('"\'')
                python_lines.append(f"        await page.goto('{url}')")
            elif line.startswith('click'):
                selector = line.split('click')[1].strip().strip('"\'')
                python_lines.append(f"        await page.click('{selector}')")
            elif line.startswith('fill'):
                parts = line.split('fill')[1].strip().split(' ', 1)
                selector = parts[0].strip('"\'')
                value = parts[1].strip('"\'') if len(parts) > 1 else ""
                python_lines.append(f"        await page.fill('{selector}', '{value}')")
            elif line.startswith('wait'):
                timeout = line.split('wait')[1].strip()
                python_lines.append(f"        await page.wait_for_timeout({timeout})")
            else:
                python_lines.append(f"        # Command: {line}")
            
            python_lines.append("        await asyncio.sleep(0.5)  # Human-like delay")
        
        python_lines.extend([
            "",
            "        return {'success': True, 'message': 'Automation completed'}",
            "    except Exception as e:",
            "        return {'success': False, 'error': str(e)}",
            "    finally:",
            "        if browser:",
            "            await browser.close()",
            "        if playwright:",
            "            await playwright.stop()",
            "",
            "async def main():",
            "    result = await execute_automation()",
            "    print(result)",
            "",
            "if __name__ == '__main__':",
            "    asyncio.run(main())"
        ])
        
        return "\n".join(python_lines)
    
    async def _detect_platform(self, blueprint: Dict[str, Any]) -> PlatformType:
        """Detect target platform from blueprint"""
        if not blueprint or "error" in blueprint:
            return PlatformType.UNKNOWN
        
        # Check explicit platform from blueprint
        if "platform" in blueprint:
            platform_str = blueprint["platform"].lower()
            if platform_str == "web":
                return PlatformType.WEB
            elif platform_str == "mobile":
                return PlatformType.MOBILE
        
        # Analyze UI elements for platform indicators
        ui_elements = blueprint.get("ui_elements", [])
        mobile_indicators = ["tap", "swipe", "scroll", "android", "ios", "mobile"]
        web_indicators = ["click", "browser", "url", "webpage", "web"]
        
        text_content = " ".join([
            elem.get("text", "").lower() for elem in ui_elements
        ])
        
        mobile_score = sum(1 for indicator in mobile_indicators if indicator in text_content)
        web_score = sum(1 for indicator in web_indicators if indicator in text_content)
        
        if mobile_score > web_score:
            return PlatformType.MOBILE
        elif web_score > mobile_score:
            return PlatformType.WEB
        else:
            # Default to mobile if uncertain
            return PlatformType.MOBILE
    
    async def _generate_script(self, blueprint: Dict[str, Any], 
                             platform: PlatformType) -> str:
        """Generate automation script based on blueprint and platform"""
        try:
            if platform == PlatformType.MOBILE:
                return await self._generate_mobile_script(blueprint)
            elif platform == PlatformType.WEB:
                return await self._generate_web_script(blueprint)
            else:
                return "# Unknown platform - cannot generate script"
                
        except Exception as e:
            return f"# Script generation failed: {str(e)}"
    
    async def _generate_mobile_script(self, blueprint: Dict[str, Any]) -> str:
        """Generate Appium mobile automation script"""
        try:
            # Create prompt for mobile script generation
            prompt = self._create_mobile_script_prompt(blueprint)
            
            # Generate script using LLM
            response = await model_client.generate(prompt)
            
            # Extract and validate script
            script = self._extract_script_from_response(response)
            
            if not script:
                return self._create_fallback_mobile_script(blueprint)
            
            return script
            
        except Exception as e:
            print(f"[{self.name}] Mobile script generation failed: {str(e)}")
            return self._create_fallback_mobile_script(blueprint)
    
    async def _generate_web_script(self, blueprint: Dict[str, Any]) -> str:
        """Generate Playwright web automation script"""
        try:
            # Create prompt for web script generation
            prompt = self._create_web_script_prompt(blueprint)
            
            # Generate script using LLM
            response = await model_client.generate(prompt)
            
            # Extract and validate script
            script = self._extract_script_from_response(response)
            
            if not script:
                return self._create_fallback_web_script(blueprint)
            
            return script
            
        except Exception as e:
            print(f"[{self.name}] Web script generation failed: {str(e)}")
            return self._create_fallback_web_script(blueprint)
    
    def _create_mobile_script_prompt(self, blueprint: Dict[str, Any]) -> str:
        """Create prompt for mobile script generation"""
        steps = blueprint.get("steps", [])
        ui_elements = blueprint.get("ui_elements", [])
        
        return f"""
Generate an Appium mobile automation Python script based on the following blueprint:

BLUEPRINT STEPS:
{json.dumps(steps, indent=2)}

UI ELEMENTS:
{json.dumps(ui_elements[:5], indent=2)}

Create a Python script using Appium WebDriver that:
1. Uses the AppiumDriver class methods
2. Implements each step from the blueprint
3. Uses bulletproof element finding (multiple strategies)
4. Includes error handling and retries
5. Takes screenshots after important steps

Script template:
```python
# Mobile automation script
def execute_automation():
    try:
        # Step 1: Find and interact with elements
        # Step 2: Handle input fields
        # Step 3: Click buttons
        # Add more steps as needed
        
        return {{"success": True, "message": "Automation completed"}}
    except Exception as e:
        return {{"success": False, "error": str(e)}}
```

Generate ONLY the Python code, no explanations.
"""
    
    def _create_web_script_prompt(self, blueprint: Dict[str, Any]) -> str:
        """Create prompt for web script generation"""
        steps = blueprint.get("steps", [])
        ui_elements = blueprint.get("ui_elements", [])
        
        return f"""
Generate a Playwright web automation Python script based on the following blueprint:

BLUEPRINT STEPS:
{json.dumps(steps, indent=2)}

UI ELEMENTS:
{json.dumps(ui_elements[:5], indent=2)}

Create a Python script using Playwright that:
1. Uses async/await syntax
2. Implements each step from the blueprint
3. Uses CSS selectors and XPath
4. Includes error handling
5. Takes screenshots after steps

Script format (simple commands, not full Python):
navigate "https://example.com"
click "button selector"
fill "input selector" "value"
wait 2000
screenshot

Generate ONLY the script commands, one per line.
"""
    
    def _extract_script_from_response(self, response: str) -> str:
        """Extract script code from LLM response"""
        try:
            # Look for code blocks
            if "```python" in response:
                start = response.find("```python") + len("```python")
                end = response.find("```", start)
                if end > start:
                    return response[start:end].strip()
            elif "```" in response:
                start = response.find("```") + 3
                end = response.find("```", start)
                if end > start:
                    return response[start:end].strip()
            else:
                # Return the whole response if no code blocks
                return response.strip()
                
        except Exception as e:
            print(f"[{self.name}] Script extraction failed: {str(e)}")
            return ""
    
    def _create_fallback_mobile_script(self, blueprint: Dict[str, Any]) -> str:
        """Create fallback mobile script when generation fails"""
        steps = blueprint.get("steps", [])
        script_lines = [
            "# Fallback mobile automation script",
            "def execute_automation():",
            "    try:",
        ]
        
        for step in steps[:5]:  # Max 5 steps
            action = step.get("action", "unknown")
            target = step.get("target_element", "unknown")
            
            if action == "click":
                script_lines.append(f'        # Click: {step.get("description", "")}')
                script_lines.append(f'        element = driver.find_element("id", "{target}")')
                script_lines.append(f'        element.click()')
                script_lines.append(f'        time.sleep(1)')
                
            elif action == "input":
                input_data = step.get("input_data", "test_value")
                script_lines.append(f'        # Input: {step.get("description", "")}')
                script_lines.append(f'        element = driver.find_element("id", "{target}")')
                script_lines.append(f'        element.send_keys("{input_data}")')
                script_lines.append(f'        time.sleep(1)')
                
            elif action == "wait":
                script_lines.append(f'        # Wait step')
                script_lines.append(f'        time.sleep(2)')
        
        script_lines.extend([
            '        return {"success": True, "message": "Fallback script completed"}',
            '    except Exception as e:',
            '        return {"success": False, "error": str(e)}'
        ])
        
        return "\n".join(script_lines)
    
    def _create_fallback_web_script(self, blueprint: Dict[str, Any]) -> str:
        """Create fallback web script when generation fails"""
        steps = blueprint.get("steps", [])
        script_lines = ["# Fallback web automation script"]
        
        for step in steps[:5]:  # Max 5 steps
            action = step.get("action", "unknown")
            target = step.get("target_element", "unknown")
            
            if action == "click":
                script_lines.append(f'click "{target}"')
            elif action == "input":
                input_data = step.get("input_data", "test_value")
                script_lines.append(f'fill "{target}" "{input_data}"')
            elif action == "wait":
                script_lines.append(f'wait 2000')
        
        script_lines.append('screenshot')
        
        return "\n".join(script_lines)

# Global code agent instance
code_agent = CodeAgent()