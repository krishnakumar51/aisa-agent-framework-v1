"""
Production Mobile Automation Script - Task 0
Generated by Enhanced Agent 2 with REAL LLM Intelligence
Task: Create an Outlook account with name Krishna Kumar and DOB 20 Sep 2000
Platform: Mobile (Android)
Generated: 2025-09-20T16:26:29.420835+00:00
"""

import logging
import time
import json
import random
import subprocess
from datetime import datetime
from pathlib import Path
from typing import Optional, Dict, Any, List, Tuple

# Mobile automation imports
from appium import webdriver
from appium.options.android import UiAutomator2Options
from appium.webdriver.common.appiumby import AppiumBy
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, StaleElementReferenceException

# OCR and image processing
try:
    import pytesseract
    from PIL import Image
    import cv2
    import numpy as np
    OCR_AVAILABLE = True
except ImportError:
    OCR_AVAILABLE = False

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('automation_execution.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)

class DynamicDeviceManager:
    """Handles dynamic Android device detection and management"""
    
    def __init__(self):
        self.device_info = None
        self.capabilities = None
    
    def detect_connected_devices(self) -> List[Dict[str, Any]]:
        """Detect all connected Android devices"""
        devices = []
        try:
            result = subprocess.run(
                ["adb", "devices", "-l"], 
                capture_output=True, 
                text=True, 
                timeout=15
            )
            
            if result.returncode == 0:
                lines = result.stdout.strip().split('\n')[1:]  # Skip header
                for line in lines:
                    if line.strip() and 'device' in line:
                        parts = line.split()
                        if len(parts) >= 2 and parts[1] == 'device':
                            device_id = parts[0]
                            device_info = self.get_device_details(device_id)
                            if device_info:
                                devices.append(device_info)
                
                logger.info(f"✅ Detected {len(devices)} connected Android devices")
                return devices
                
        except Exception as e:
            logger.error(f"❌ Device detection failed: {str(e)}")
            return []
    
    def get_device_details(self, device_id: str) -> Optional[Dict[str, Any]]:
        """Get detailed information about a specific device"""
        try:
            device_info = {
                "device_id": device_id,
                "device_name": "Android Device",
                "is_emulator": device_id.startswith("emulator-"),
            }
            
            # Set display name
            if device_info["is_emulator"]:
                device_info["device_name"] = f"Android Emulator ({device_id})"
            else:
                device_info["device_name"] = f"Android Device ({device_id})"
            
            return device_info
            
        except Exception as e:
            logger.error(f"❌ Failed to get device details for {device_id}: {str(e)}")
            return None
    
    def select_best_device(self) -> Optional[Dict[str, Any]]:
        """Select the best available device for automation"""
        devices = self.detect_connected_devices()
        if not devices:
            logger.error("❌ No connected Android devices found")
            return None
        
        # Prefer real devices over emulators
        real_devices = [d for d in devices if not d['is_emulator']]
        selected = real_devices[0] if real_devices else devices[0]
        
        self.device_info = selected
        logger.info(f"✅ Selected device: {selected['device_name']}")
        return selected
    
    def create_capabilities(self) -> Dict[str, Any]:
        """Create Appium capabilities for the selected device"""
        if not self.device_info:
            raise Exception("No device selected")
        
        capabilities = {
            "platformName": "Android",
            "deviceName": self.device_info["device_name"],
            "udid": self.device_info["device_id"],
            "automationName": "UiAutomator2",
            "noReset": False,
            "fullReset": False,
            "newCommandTimeout": 300,
            "unicodeKeyboard": True,
            "resetKeyboard": True,
            "autoGrantPermissions": True,
            "systemPort": 8200 + random.randint(1, 99),  # Dynamic port
        }
        
        self.capabilities = capabilities
        return capabilities

class ProductionMobileAutomation:
    """Production-ready mobile automation with LLM-generated intelligence"""
    
    def __init__(self):
        self.driver = None
        self.device_manager = DynamicDeviceManager()
        self.ocr_logs_dir = Path("ocr_logs")
        self.ocr_logs_dir.mkdir(exist_ok=True)
        self.screen_size = None
        self.step_results = []
        
        # User data for automation (LLM-contextualized)
        self.user_data = {"name": "Krishna Kumar", "dob": "20", "temp_task_id": "temp_1758385587", "email": "krishna.kumar@example.com", "password": "SecurePass123!"}
    
    def setup_driver(self) -> bool:
        """Setup Appium driver with dynamic device detection"""
        try:
            logger.info("🚀 Setting up mobile automation driver...")
            
            # Select best device
            device = self.device_manager.select_best_device()
            if not device:
                raise Exception("No suitable device found")
            
            # Create capabilities
            capabilities = self.device_manager.create_capabilities()
            logger.info(f"📱 Device capabilities: {json.dumps(capabilities, indent=2)}")
            
            # Initialize driver
            self.driver = webdriver.Remote(
                "http://localhost:4723", 
                options=UiAutomator2Options().load_capabilities(capabilities)
            )
            self.driver.implicitly_wait(10)
            
            # Get screen size
            self.screen_size = self.driver.get_window_size()
            logger.info(f"📱 Screen resolution: {self.screen_size['width']}x{self.screen_size['height']}")
            
            logger.info("✅ Mobile driver initialized successfully")
            return True
            
        except Exception as e:
            logger.error(f"❌ Driver setup failed: {str(e)}")
            return False
    
    def enhanced_screenshot_with_ocr(self, step_name: str) -> Tuple[str, str]:
        """Take screenshot with enhanced OCR processing"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        screenshot_path = self.ocr_logs_dir / f"{step_name}_{timestamp}.png"
        
        if not self.driver:
            return "", ""
        
        try:
            # Take screenshot
            self.driver.save_screenshot(str(screenshot_path))
            
            # OCR processing if available
            ocr_text = ""
            if OCR_AVAILABLE:
                try:
                    import pytesseract
                    from PIL import Image
                    
                    image = Image.open(screenshot_path)
                    ocr_text = pytesseract.image_to_string(image)
                except Exception as e:
                    logger.warning(f"⚠️ OCR processing failed: {str(e)}")
            
            logger.info(f"📸 Screenshot saved: {screenshot_path}")
            return str(screenshot_path), ocr_text
            
        except Exception as e:
            logger.error(f"❌ Screenshot failed: {str(e)}")
            return "", ""
    
    def smart_element_finder(self, locator_strategies: List[Dict[str, str]], wait_time: int = 10) -> Optional[Any]:
        """Smart element finding with multiple strategies"""
        wait = WebDriverWait(self.driver, wait_time)
        
        for strategy in locator_strategies:
            try:
                by_type = strategy.get("by", "xpath")
                value = strategy.get("value", "")
                
                # Map string locator types to AppiumBy constants
                by_mapping = {
                    "id": AppiumBy.ID,
                    "xpath": AppiumBy.XPATH,
                    "class_name": AppiumBy.CLASS_NAME,
                    "accessibility_id": AppiumBy.ACCESSIBILITY_ID,
                    "android_uiautomator": AppiumBy.ANDROID_UIAUTOMATOR,
                }
                
                locator = by_mapping.get(by_type, AppiumBy.XPATH)
                element = wait.until(EC.presence_of_element_located((locator, value)))
                
                logger.info(f"✅ Element found using {by_type}: {value}")
                return element
                
            except TimeoutException:
                continue
            except Exception as e:
                continue
        
        return None
    
    def smart_tap(self, x: int, y: int) -> bool:
        """Smart tap with coordinate validation"""
        try:
            if x < 0 or y < 0 or x > self.screen_size["width"] or y > self.screen_size["height"]:
                return False
            
            self.driver.tap([(x, y)], 100)
            logger.info(f"✅ Tapped at coordinates: ({x}, {y})")
            time.sleep(1)
            return True
            
        except Exception as e:
            logger.error(f"❌ Tap failed: {str(e)}")
            return False
    
    def safe_send_keys(self, element, input_text: str, clear_first: bool = True) -> bool:
        """Safe text input with validation"""
        try:
            if clear_first:
                element.clear()
                time.sleep(0.5)
                
            element.send_keys(input_text)
            logger.info(f"✅ Text entered: {input_text}")
            time.sleep(1)
            return True
            
        except Exception as e:
            logger.error(f"❌ Text input failed: {str(e)}")
            return False
    def run_automation(self) -> bool:
        """Execute the complete automation workflow with LLM-generated intelligence"""
        workflow_start_time = time.time()
        
        try:
            logger.info("🚀 Starting LLM-powered mobile automation...")
            logger.info(f"📋 Task: Create an Outlook account with name Krishna Kumar and DOB 20 Sep 2000")
            logger.info(f"👤 User Data: {json.dumps(self.user_data, indent=2)}")
            
            if not self.setup_driver():
                raise Exception("Failed to setup mobile driver")
            
            # LLM-GENERATED STEP IMPLEMENTATIONS:
            
            
            # Save comprehensive results
            execution_time = time.time() - workflow_start_time
            results_summary = {
                "task_id": 0,
                "instruction": "Create an Outlook account with name Krishna Kumar and DOB 20 Sep 2000",
                "execution_time": execution_time,
                "execution_timestamp": datetime.utcnow().isoformat(),
                "device_info": self.device_manager.device_info,
                "screen_size": self.screen_size,
                "total_steps": len(self.step_results),
                "completed_steps": len([r for r in self.step_results if r["status"] == "completed"]),
                "failed_steps": len([r for r in self.step_results if r["status"] == "failed"]),
                "success_rate": len([r for r in self.step_results if r["status"] == "completed"]) / len(self.step_results) * 100 if self.step_results else 0,
                "user_data": self.user_data,
                "results": self.step_results,
                "generation_method": "LLM_INTELLIGENT"
            }
            
            # Save results
            results_path = self.ocr_logs_dir / "automation_results.json"
            with open(results_path, 'w', encoding='utf-8') as f:
                json.dump(results_summary, f, indent=2, ensure_ascii=False)
            
            success_count = results_summary["completed_steps"]
            total_count = results_summary["total_steps"]
            
            logger.info(f"🎯 LLM-powered automation completed: {success_count}/{total_count} steps successful")
            logger.info(f"⏱️ Total execution time: {execution_time:.2f} seconds")
            logger.info(f"📊 Success rate: {results_summary['success_rate']:.1f}%")
            
            return results_summary["success_rate"] >= 70.0
            
        except Exception as e:
            logger.error(f"❌ LLM-powered mobile automation failed: {str(e)}")
            return False
            
        finally:
            if self.driver:
                try:
                    self.driver.quit()
                    logger.info("✅ Mobile driver cleaned up")
                except:
                    pass

if __name__ == "__main__":
    automation = ProductionMobileAutomation()
    success = automation.run_automation()
    
    print("-" * 50)
    print(f"AUTOMATION RESULT: {'SUCCESS' if success else 'FAILED'}")
    print(f"GENERATION METHOD: LLM-INTELLIGENT")
    print("-" * 50)
    
    exit(0 if success else 1)